# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Approximation Algorithms
#' @name Approximation-Algorithms
#' @param arcSources, a vector corresponding to the source nodes of a graph's edges
#' @param arcTargets, a vector corresponding to the destination nodes of a graph's edges
#' @param numNodes, the number of nodes in the graph
#' @return a List with 1) the clique size, and 2) the members of the clique
NULL

#' @rdname Approximation-Algorithms
#' @description `GrossoLocatelliPullanMcRunner` runs the Grosso, Locatelli, and Pullan for solving the maximum clique problem
#' @export
GrossoLocatelliPullanMcRunner <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_GrossoLocatelliPullanMcRunner`, arcSources, arcTargets, numNodes)
}

#' Graph Input Specifications
#' @name Input-Information
#' @description Due to how LEMON operates, and to make the interfaces similar to the actual program,
#' graphs in rLEMON use the following 2 vectors:
#' arcSources, and arcTargets
#' to acquire information about how the graph is structured
#' each edge in a graph will consist of a (node id, node id) pair, which is represented
#' by the ith entry in both arcSources and arcTargets.
#' The nodes are 0-indexed, and must be sequential.
#' numNodes must be equal to the number of nodes in the graph, as otherwise there
#' are potentials to error out.
#' As an example, the cycle graph on three vertices would have the following input:
#' arcSources <- c(0,1,2)
#' arcTargets <- c(1,2,0)
#' numNodes <- 3
#' Here, the edges are (0,1), (1,2), (2,0)
NULL

#' Connectivity Algorithms - Boolean Return
#' @name Connectivity-Algorithms-1
#' @param arcSources, a vector corresponding to the source nodes of a graph's edges
#' @param arcTargets, a vector corresponding to the destination nodes of a graph's edges
#' @param numNodes, the number of nodes in the graph
#' @return a boolean, stating if a graph has some property
NULL

#' Connectivity Algorithms - Integer Return
#' @name Connectivity-Algorithms-2
#' @param arcSources, a vector corresponding to the source nodes of a graph's edges
#' @param arcTargets, a vector corresponding to the destination nodes of a graph's edges
#' @param numNodes, the number of nodes in the graph
#' @return an integer, counting some property of a graph
NULL

#' Connectivity Algorithms - List Return
#' @name Connectivity-Algorithms-3
#' @param arcSources, a vector corresponding to the source nodes of a graph's edges
#' @param arcTargets, a vector corresponding to the destination nodes of a graph's edges
#' @param numNodes, the number of nodes in the graph
#' @return a List, returning some set of nodes or edges in a graph
NULL

#' @rdname Connectivity-Algorithms-3
#' @return `getBipartitePartitions` returns an R List containing (1) A boolean stating if the graph is bipartite, and (2) an std::vector of length numNodes, containing the partition for each node
#' @export
getBipartitePartitions <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_getBipartitePartitions`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-3
#' @return `getAndCheckTopologicalSort` returns an R List containing (1) A boolean stating if the graph is a dag, and (2) a vector of length numNodes, containing the index of vertex i in the ordering at location i
#' @export
getAndCheckTopologicalSort <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_getAndCheckTopologicalSort`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-3
#' @return `getTopologicalSort` returns a vector of length numNodes, containing the index of vertex i in the ordering at location i.
#' @export
getTopologicalSort <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_getTopologicalSort`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-1
#' @description `IsConnected` returns if a graph is connected or not
#' @examples
#' data(small_graph_example)
#' start <- small_graph_example$startnodes
#' end <- small_graph_example$endnodes
#' numnodes <- length(unique(c(start, end)))
#' IsConnected(start, end, numnodes)
#' @export
IsConnected <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_IsConnected`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-1
#' @description `IsAcyclic` returns if a graph is acyclic or not
#' @export
IsAcyclic <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_IsAcyclic`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-1
#' @description `IsTree` returns if a graph is a tree or not
#' @export
IsTree <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_IsTree`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-1
#' @description `IsBipartite` returns if a graph is bipartite or not
#' @export
IsBipartite <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_IsBipartite`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-1
#' @description `IsStronglyConnected` returns if a graph is strongly connected or not
#' @export
IsStronglyConnected <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_IsStronglyConnected`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-1
#' @description `IsDAG` returns if a graph is a DAG or not
#' @export
IsDAG <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_IsDAG`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-1
#' @description `IsBiNodeConnected` returns if a graph is bi-node connected or not
#' @export
IsBiNodeConnected <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_IsBiNodeConnected`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-1
#' @description `IsBiEdgeConnected` returns if a graph is bi-edge connected or not
#' @export
IsBiEdgeConnected <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_IsBiEdgeConnected`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-1
#' @description `IsLoopFree` returns if a graph is loop-free or not
#' @export
IsLoopFree <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_IsLoopFree`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-1
#' @description `IsParallelFree` returns if a graph is parallel-free or not
#' @export
IsParallelFree <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_IsParallelFree`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-1
#' @description `IsSimpleGraph` returns if a graph is simple or not
#' @export
IsSimpleGraph <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_IsSimpleGraph`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-1
#' @description `IsEulerian` returns if a graph is eulerian or not
#' @export
IsEulerian <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_IsEulerian`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-2
#' @description `CountBiEdgeConnectedComponents` returns how many Bi-Edge Connected Components a graph has.
#' @export
CountBiEdgeConnectedComponents <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_CountBiEdgeConnectedComponents`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-2
#' @description `CountConnectedComponents` returns how many Connected Components a graph has.
#' @export
CountConnectedComponents <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_CountConnectedComponents`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-2
#' @description `CountBiNodeConnectedComponents` returns how many Bi-Node Connected Components a graph has.
#' @export
CountBiNodeConnectedComponents <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_CountBiNodeConnectedComponents`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-2
#' @description `CountStronglyConnectedComponents` returns how many Strongly Connected Components a graph has.
#' @export
CountStronglyConnectedComponents <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_CountStronglyConnectedComponents`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-3
#' @description `FindStronglyConnectedComponents` returns a vector containing the component number of each node
#' @export
FindStronglyConnectedComponents <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_FindStronglyConnectedComponents`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-3
#' @description `FindStronglyConnectedCutArcs` returns an R List containing 1) A list of cut arc sources, and 2) A list of cut arc destinations
#' @export
FindStronglyConnectedCutArcs <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_FindStronglyConnectedCutArcs`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-3
#' @description `FindBiEdgeConnectedCutEdges` returns an R List containing 1) A list of cut edge sources, and 2) A list of cut edge destinations
#' @export
FindBiEdgeConnectedCutEdges <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_FindBiEdgeConnectedCutEdges`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-3
#' @description `FindBiNodeConnectedCutComponents` returns a vector containing the component number of each cut arc.
#' @export
FindBiNodeConnectedComponents <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_FindBiNodeConnectedComponents`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-3
#' @description `FindBiNodeConnectedCutNodes` returns a vector containing the cut nodes
#' @export
FindBiNodeConnectedCutNodes <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_FindBiNodeConnectedCutNodes`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-3
#' @description `FindConnectedComponents` returns a vector containing the component number of each node
#' @export
FindConnectedComponents <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_FindConnectedComponents`, arcSources, arcTargets, numNodes)
}

#' @rdname Connectivity-Algorithms-3
#' @description `FindBiEdgeConnectedComponents` returns a vector containing the component number of each node
FindBiEdgeConnectedComponents <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_FindBiEdgeConnectedComponents`, arcSources, arcTargets, numNodes)
}

#' Maximum  Flow Algorithms - Network Circulation
#' @name Maximum Flow Algorithms 2
#' @param arcSources, a vector corresponding to the source nodes of a graph's edges
#' @param arcTargets, a vector corresponding to the destination nodes of a graph's edges
#' @param arcLowerBound, a vector corresponding to the lower-bound capacities of nodes of a graph's edges
#' @param arcUpperBound, a vector corresponding to the upper-bound capacities of nodes of a graph's edges
#' @param nodeSupplies, a vector corresponding to the supplies of each node of the graph.
#' @param numNodes, the number of nodes in the graph
#' @return A list containing three entries: 1) A list corresponding to the flows of arcs in the graph, 2) A list of the graph's barrier nodes, and 3) the total cost of the flows in the graph, i.e. the maxflow value
NULL

#' Maximum  Flow Algorithms
#' @name Maximum Flow Algorithms
#' @param arcSources, a vector corresponding to the source nodes of a graph's edges
#' @param arcTargets, a vector corresponding to the destination nodes of a graph's edges
#' @param arcDistances, a vector corresponding to the capacities of nodes of a graph's edges
#' @param sourceNode, the source node
#' @param destinationNode, the destination node
#' @param numNodes, the number of nodes in the graph
#' @return A list containing three entries: 1) A list corresponding to the flows of arcs in the graph, and 2) A list of cut-values of the graph's nodes.
NULL

#' @rdname Maximum-Flow-Algorithms-2
#' @description `PreflowRunner` runs the Preflow Algorithm to calculate the maximum flow.
#' @export
CirculationRunner <- function(arcSources, arcTargets, arcLowerBound, arcUpperBound, nodeSupplies, numNodes) {
    .Call(`_rlemon_CirculationRunner`, arcSources, arcTargets, arcLowerBound, arcUpperBound, nodeSupplies, numNodes)
}

#' @rdname Maximum-Flow-Algorithms
#' @description `PreflowRunner` runs the Preflow Algorithm to calculate the maximum flow.
PreflowRunner <- function(arcSources, arcTargets, arcDistances, sourceNode, destinationNode, numNodes) {
    .Call(`_rlemon_PreflowRunner`, arcSources, arcTargets, arcDistances, sourceNode, destinationNode, numNodes)
}

#' @rdname Maximum-Flow-Algorithms
#' @description `EdmondsKarpRunner` runs the EdmondsKarp Algorithm to calculate the maximum flow.
EdmondsKarpRunner <- function(arcSources, arcTargets, arcDistances, sourceNode, destinationNode, numNodes) {
    .Call(`_rlemon_EdmondsKarpRunner`, arcSources, arcTargets, arcDistances, sourceNode, destinationNode, numNodes)
}

#' Maximum Matching Algorithms
#' @name Maximum-Matching-Algorithms
#' @param arcSources, a vector corresponding to the source nodes of a graph's edges
#' @param arcTargets, a vector corresponding to the destination nodes of a graph's edges
#' @param arcWeights, a vector corresponding to the weights of a graph's edges
#' @param numNodes, the number of nodes in the graph
#' @return A list containing two entries: 1) The matching value, 2) The edges of the final graph, in a List of List of (node, node) pairs
NULL

#' @rdname Maximum-Matching-Algorithms
#' @description `MaximumWeightPerfectMatchingRunner` solves the Maximum-Weight Perfect Matching Problem
MaximumWeightPerfectMatchingRunner <- function(arcSources, arcTargets, arcWeights, numNodes) {
    .Call(`_rlemon_MaximumWeightPerfectMatchingRunner`, arcSources, arcTargets, arcWeights, numNodes)
}

#' @rdname Maximum-Matching-Algorithms
#' @description `MaximumWeightFractionalPerfectMatchingRunner` solves the Maximum-Weight Fractional Perfect Matching Problem
MaximumWeightFractionalPerfectMatchingRunner <- function(arcSources, arcTargets, arcWeights, numNodes) {
    .Call(`_rlemon_MaximumWeightFractionalPerfectMatchingRunner`, arcSources, arcTargets, arcWeights, numNodes)
}

#' @rdname Maximum-Matching-Algorithms
#' @description `MaximumWeightFractionalMatchingRunner` solves the Maximum-Weight Fractional Matching Problem
MaximumWeightFractionalMatchingRunner <- function(arcSources, arcTargets, arcWeights, numNodes) {
    .Call(`_rlemon_MaximumWeightFractionalMatchingRunner`, arcSources, arcTargets, arcWeights, numNodes)
}

#' @rdname Maximum-Matching-Algorithms
#' @description `MaximumWeightMatchingRunner` solves the Maximum-Weight Matching Problem
MaximumWeightMatchingRunner <- function(arcSources, arcTargets, arcWeights, numNodes) {
    .Call(`_rlemon_MaximumWeightMatchingRunner`, arcSources, arcTargets, arcWeights, numNodes)
}

#' @rdname Maximum-Matching-Algorithms
#' @description `MaximumCardinalityMatchingRunner` solves the Maximum Cardinality Matching Problem
MaximumCardinalityMatchingRunner <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_MaximumCardinalityMatchingRunner`, arcSources, arcTargets, numNodes)
}

#' @rdname Maximum-Matching-Algorithms
#' @description `MaximumCardinalityFractionalMatchingRunner` solves the Maximum-Cardinality Fractional Matching Problem
MaximumCardinalityFractionalMatchingRunner <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_MaximumCardinalityFractionalMatchingRunner`, arcSources, arcTargets, numNodes)
}

#' MST Algorithms
#' @name Minimum Spanning Tree Algorithms
#' @param arcSources, a vector corresponding to the source nodes of a graph's edges
#' @param arcTargets, a vector corresponding to the destination nodes of a graph's edges
#' @param arcDistances, a vector corresponding to the distances of nodes of a graph's edges
#' @param numNodes, the number of nodes in the graph
#' @return A list containing three entries: 1) Two vectors corresponding the source and target nodes of the edges in the trre, and 2) the total minimum spanning tree value.
NULL

#' Arborescence Algorithms
#' @name Minimum Cost Arborescence Algorithms
#' @param arcSources, a vector corresponding to the source nodes of a graph's edges
#' @param arcTargets, a vector corresponding to the destination nodes of a graph's edges
#' @param arcDistances, a vector corresponding to the distances of nodes of a graph's edges
#' @param sourceNode, the source node
#' @param numNodes, the number of nodes in the graph
#' @return A list containing three entries: 1) Two vectors corresponding the source and target nodes of the edges in the tree, and 2) the total minimum spanning tree value.
NULL

#' @rdname Minimum-Spanning-Tree-Algorithms
KruskalRunner <- function(arcSources, arcTargets, arcDistances, numNodes) {
    .Call(`_rlemon_KruskalRunner`, arcSources, arcTargets, arcDistances, numNodes)
}

#' @rdname Minimum-Cost-Arborescence-Algorithms
MinCostArborescenceRunner <- function(arcSources, arcTargets, arcDistances, sourceNode, numNodes) {
    .Call(`_rlemon_MinCostArborescenceRunner`, arcSources, arcTargets, arcDistances, sourceNode, numNodes)
}

#' Minimum Cost Flow Algorithms
#' @name Minimum Cost Flow Algorithms
#' @param arcSources, a vector corresponding to the source nodes of a graph's edges
#' @param arcTargets, a vector corresponding to the destination nodes of a graph's edges
#' @param arcCapacities, a vector corresponding to the capacities of nodes of a graph's edges
#' @param arcCosts, a vector corresponding to the capacities of nodes of a graph's edges
#' @param nodeSupplies, a vector corresponding to the supplies of each node
#' @param numNodes, the number of nodes in the graph
#' @return A list containing three entries: 1) A list corresponding to the flows of arcs in the graph, 2) A list of potentials of the graph's nodes, and 3) the total cost of the flows in the graph, i.e. the mincostflow value
NULL

#' @rdname Minimum-Cost-Flow-Algorithms
#' @description `CycleCancellingRunner` runs the Cycle-Cancelling Algorithm to calculate the minimum cost flow.
CycleCancellingRunner <- function(arcSources, arcTargets, arcCapacities, arcCosts, nodeSupplies, numNodes) {
    .Call(`_rlemon_CycleCancellingRunner`, arcSources, arcTargets, arcCapacities, arcCosts, nodeSupplies, numNodes)
}

#' @rdname Minimum-Cost-Flow-Algorithms
#' @description `CapacityScalingRunner` runs the Capacity-Scaling Algorithm to calculate the minimum cost flow.
CapacityScalingRunner <- function(arcSources, arcTargets, arcCapacities, arcCosts, nodeSupplies, numNodes) {
    .Call(`_rlemon_CapacityScalingRunner`, arcSources, arcTargets, arcCapacities, arcCosts, nodeSupplies, numNodes)
}

#' @rdname Minimum-Cost-Flow-Algorithms
#' @description `CostScalingRunner` runs the Cost-Scaling Algorithm to calculate the minimum cost flow.
CostScalingRunner <- function(arcSources, arcTargets, arcCapacities, arcCosts, nodeSupplies, numNodes) {
    .Call(`_rlemon_CostScalingRunner`, arcSources, arcTargets, arcCapacities, arcCosts, nodeSupplies, numNodes)
}

#' @rdname Minimum-Cost-Flow-Algorithms
#' @description `NetworkSimplexRunner` runs the Network-Simplex Algorithm to calculate the minimum cost flow.
NetworkSimplexRunner <- function(arcSources, arcTargets, arcCapacities, arcCosts, nodeSupplies, numNodes) {
    .Call(`_rlemon_NetworkSimplexRunner`, arcSources, arcTargets, arcCapacities, arcCosts, nodeSupplies, numNodes)
}

#' Minimum Cut Algorithms - Gomory Hu Tree
#' @name Minimum Cut Algorithms 2
#' @param arcSources, a vector corresponding to the source nodes of a graph's edges
#' @param arcTargets, a vector corresponding to the destination nodes of a graph's edges
#' @param arcWeights, a vector corresponding to the weights of a graph's edges
#' @param numNodes, the number of nodes in the graph
#' @return Calculates a Gomory-Hu Tree and returns a list containing three entries: 1) A list of predecessor nodes of each node in the graph, and 2) A list of weights of the predecessor edge of each node, and 3) A list of distances from the root node to each node.
NULL

#' Minimum Cut Algorithms
#' @name Minimum Cut Algorithms
#' @param arcSources, a vector corresponding to the source nodes of a graph's edges
#' @param arcTargets, a vector corresponding to the destination nodes of a graph's edges
#' @param arcWeights, a vector corresponding to the weights of a graph's edges
#' @param numNodes, the number of nodes in the graph
#' @return A list containing three entries: 1) The value of the minimum cut in the graph, and 2) A list of nodes in the first partition, and 3) A list of nodes in the second partition.
NULL

#' @rdname Minimum-Cut-Algorithms
#' @description `NagamochiIbarakiRunner` runs the Nagamochi-Ibaraki Algorithm to calculate the minimum cut.
#' @export
NagamochiIbarakiRunner <- function(arcSources, arcTargets, arcWeights, numNodes) {
    .Call(`_rlemon_NagamochiIbarakiRunner`, arcSources, arcTargets, arcWeights, numNodes)
}

#' @rdname Minimum-Cut-Algorithms
#' @description `HaoOrlinRunner` runs the Hao-Orlin Algorithm to calculate the minimum cut.
#' @export
HaoOrlinRunner <- function(arcSources, arcTargets, arcWeights, numNodes) {
    .Call(`_rlemon_HaoOrlinRunner`, arcSources, arcTargets, arcWeights, numNodes)
}

#' @rdname Minimum-Cut-Algorithms-2
#' @description `GomoryHuTreeRunner` runs the Gomory-Hu Algorithm to calculate a rooted Gomory Hu Tree.
#' @export
GomoryHuTreeRunner <- function(arcSources, arcTargets, arcWeights, numNodes) {
    .Call(`_rlemon_GomoryHuTreeRunner`, arcSources, arcTargets, arcWeights, numNodes)
}

#' Minimum Mean-Cycle Algorithms
#' @name Maximum-Mean-Cycle-Algorithms
#' @param arcSources, a vector corresponding to the source nodes of a graph's edges
#' @param arcTargets, a vector corresponding to the destination nodes of a graph's edges
#' @param arcDistances, a vector corresponding to the distances of a graph's edges
#' @param numNodes, the number of nodes in the graph
#' @return A list containing two entries: 1) A vector containing the costs of each edge in the MMC cycle, and 2) the nodes in the MMC cycle.
NULL

#' @rdname Maximum-Mean-Cycle-Algorithms
#' @description `HowardMmcRunner` runs Howard's policy iteration algorithm.
HowardMmcRunner <- function(arcSources, arcTargets, arcDistances, numNodes) {
    .Call(`_rlemon_HowardMmcRunner`, arcSources, arcTargets, arcDistances, numNodes)
}

#' @rdname Maximum-Mean-Cycle-Algorithms
#' @description `KarpMmcRunner` runs Karp's algorithm.
KarpMmcRunner <- function(arcSources, arcTargets, arcDistances, numNodes) {
    .Call(`_rlemon_KarpMmcRunner`, arcSources, arcTargets, arcDistances, numNodes)
}

#' @rdname Maximum-Mean-Cycle-Algorithms
#' @description `HartmannOrlinMmcRunner` runs Hartmann-Orlin's algorithm algorithm.
HartmannOrlinMmcRunner <- function(arcSources, arcTargets, arcDistances, numNodes) {
    .Call(`_rlemon_HartmannOrlinMmcRunner`, arcSources, arcTargets, arcDistances, numNodes)
}

#' Planar Embedding Algorithms
#' @name Planar-Embedding-Algorithms
#' @param arcSources, a vector corresponding to the source nodes of a graph's edges
#' @param arcTargets, a vector corresponding to the destination nodes of a graph's edges
#' @param numNodes, the number of nodes in the graph
#' @return assorted values, depending on the function
NULL

#' @rdname Planar-Embedding-Algorithms
#' @description `PlanarCheckingRunner` returns a bool stating if a graph is planar or not.
#' @export
PlanarCheckingRunner <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_PlanarCheckingRunner`, arcSources, arcTargets, numNodes)
}

#' @rdname Planar-Embedding-Algorithms
#' @description `PlanarColoringRunner` returns a List containing 1) a Boolean stating if a graph is planar or not, 2) a vector containing the colors of each node, represented as integers
#' @param useFiveAlg, a boolean that asks if you want to 5-color a graph. If false, runs a faster 6-coloring algorithm instead.
#' @export
PlanarColoringRunner <- function(arcSources, arcTargets, numNodes, useFiveAlg = TRUE) {
    .Call(`_rlemon_PlanarColoringRunner`, arcSources, arcTargets, numNodes, useFiveAlg)
}

#' @rdname Planar-Embedding-Algorithms
#' @description `PlanarCheckingRunner` returns a List containing 1) a Boolean stating if a graph is planar or not, 2) a vector containing the x-coords of each node and 3) a vector containing the y-coords of each node
#' @export
PlanarDrawingRunner <- function(arcSources, arcTargets, numNodes) {
    .Call(`_rlemon_PlanarDrawingRunner`, arcSources, arcTargets, numNodes)
}

#' Travelling Salesman Algorithms on Full Graphs
#' @name TSP-Algorithms
#' @param arcSources, a vector corresponding to the source nodes of a graph's edges
#' @param arcTargets, a vector corresponding to the destination nodes of a graph's edges
#' @param arcDistances, a vector corresponding to the distances of a graph's edges
#' @param numNodes, the number of nodes in the graph
#' @param defaultEdgeWeight, the default edge weight if an edge is not-specified (default value 999999)
#' @return a List with 1) the list of tour vertices, and 2) the total tour cost
NULL

#' @rdname TSP-Algorithms
#' @description `ChristofidesRunner` runs the Christofides Heuristic
ChristofidesRunner <- function(arcSources, arcTargets, arcDistances, numNodes, defaultEdgeWeight = 999999L) {
    .Call(`_rlemon_ChristofidesRunner`, arcSources, arcTargets, arcDistances, numNodes, defaultEdgeWeight)
}

#' @rdname TSP-Algorithms
#' @description `GreedyTSPRunner` runs the Greedy Heuristic
GreedyTSPRunner <- function(arcSources, arcTargets, arcDistances, numNodes, defaultEdgeWeight = 999999L) {
    .Call(`_rlemon_GreedyTSPRunner`, arcSources, arcTargets, arcDistances, numNodes, defaultEdgeWeight)
}

#' @rdname TSP-Algorithms
#' @description `InsertionTSPRunner` runs the Insertion Heuristic
InsertionTSPRunner <- function(arcSources, arcTargets, arcDistances, numNodes, defaultEdgeWeight = 999999L) {
    .Call(`_rlemon_InsertionTSPRunner`, arcSources, arcTargets, arcDistances, numNodes, defaultEdgeWeight)
}

#' @rdname TSP-Algorithms
#' @description `NearestNeighborTSPRunner` runs the Nearest-Neighbor Heuristic
NearestNeighborTSPRunner <- function(arcSources, arcTargets, arcDistances, numNodes, defaultEdgeWeight = 999999L) {
    .Call(`_rlemon_NearestNeighborTSPRunner`, arcSources, arcTargets, arcDistances, numNodes, defaultEdgeWeight)
}

#' @rdname TSP-Algorithms
#' @description `Opt2TSPRunner` runs a 2-OPT heuristic
Opt2TSPRunner <- function(arcSources, arcTargets, arcDistances, numNodes, defaultEdgeWeight = 999999L) {
    .Call(`_rlemon_Opt2TSPRunner`, arcSources, arcTargets, arcDistances, numNodes, defaultEdgeWeight)
}

